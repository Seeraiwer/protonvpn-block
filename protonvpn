#!/usr/bin/env bash
# ProtonVPN Status pour i3blocks - Version am√©lior√©e
# Affiche le statut de ProtonVPN dans la barre i3blocks

# Mode strict pour √©viter les erreurs silencieuses
set -euo pipefail
IFS=$'\n\t'

# ===== Configuration =====
# Peut √™tre modifi√©e selon vos besoins
DEBUG_MODE=0                                      # 0=d√©sactiv√©, 1=activ√©
DEBUG_FILE="/tmp/protonvpn_debug.log"             # Fichier de logs
CACHE_DIR="/tmp/protonvpn_status"                 # Dossier de cache
CACHE_TIMEOUT=300                                 # Dur√©e de validit√© du cache (5 minutes)
VPN_LOG_PATH="$HOME/.cache/Proton/VPN/logs/vpn-app.log"  # Chemin des logs ProtonVPN
CONFIG_DIR="$HOME/.config/protonvpn-status"       # Dossier de configuration
CONFIG_FILE="$CONFIG_DIR/config"                  # Fichier de configuration
TOGGLE_FILE="$CACHE_DIR/show_ip_toggle"           # Fichier pour l'√©tat du toggle IP
IP_SERVICES=(                                     # Services pour obtenir l'IP publique
  "https://ifconfig.me"
  "https://api.ipify.org"
  "https://icanhazip.com"
)
COUNTRY_SERVICES=(                                # Services pour obtenir le code pays
  "https://ipinfo.io/%s/country"                  # %s sera remplac√© par l'IP
  "https://ip-api.com/line/%s?fields=countryCode" # Alternative
)
DISCONNECTED_MSG="‚ö†Ô∏è No VPN ‚ö†Ô∏è"                   # Message quand d√©connect√©
NO_IP_MSG="‚ö†Ô∏è No VPN ‚ö†Ô∏è (no public IP)"           # Message quand pas d'IP publique
TIMEOUT=2                                         # Timeout pour les requ√™tes curl (secondes)

# ===== Traitement des arguments =====
for arg in "$@"; do
  case "$arg" in
    --debug) DEBUG_MODE=1 ;;
    --clear-cache) rm -rf "$CACHE_DIR"; mkdir -p "$CACHE_DIR" ;;
    --help) 
      echo "Usage: $0 [options]"
      echo "Options:"
      echo "  --debug       Active le mode debug"
      echo "  --clear-cache Efface le cache"
      echo "  --help        Affiche cette aide"
      exit 0
      ;;
  esac
done

# ===== Fonctions =====

# Validation IP (IPv4 ou IPv6)
is_valid_ip() {
  local ip="$1"
  if [[ "$ip" =~ ^([0-9]{1,3}\.){3}[0-9]{1,3}$ ]]; then
    return 0
  fi
  if [[ "$ip" == *:* && "$ip" =~ ^[0-9A-Fa-f:]+$ ]]; then
    return 0
  fi
  return 1
}

# Ecriture cache avec verrou si disponible
write_cache() {
  local path="$1"
  local content="$2"
  if command -v flock >/dev/null 2>&1; then
    local lock_fd
    exec {lock_fd}>"$CACHE_DIR/.lock"
    if flock -w 1 "$lock_fd"; then
      printf '%s\n' "$content" > "$path"
      flock -u "$lock_fd"
      return 0
    fi
  fi
  printf '%s\n' "$content" > "$path"
}

# Fonction de logging
debug_log() {
  if [[ $DEBUG_MODE -eq 1 ]]; then
    echo "DEBUG: $1" >> "$DEBUG_FILE"
  fi
}

# Initialisation
init() {
  # Cr√©er les dossiers n√©cessaires
  mkdir -p "$CACHE_DIR"
  
  # Initialiser le debug si activ√©
  if [[ $DEBUG_MODE -eq 1 ]]; then
    touch "$DEBUG_FILE"
    echo "DEBUG: Script started at $(date)" > "$DEBUG_FILE"
  fi
  
  # Charger la configuration personnalis√©e si elle existe
  if [[ -f "$CONFIG_FILE" ]]; then
    debug_log "Loading config from $CONFIG_FILE"
    # shellcheck source=/dev/null
    source "$CONFIG_FILE"
  fi
}

# Fonction pour v√©rifier si le cache est valide
is_cache_valid() {
  local cache_file="$1"
  local timeout="$2"
  
  if [[ ! -f "$cache_file" ]]; then
    return 1
  fi
  
  local cache_time
  cache_time=$(stat -c %Y "$cache_file" 2>/dev/null || echo 0)
  local current_time
  current_time=$(date +%s)
  
  if (( current_time - cache_time > timeout )); then
    return 1
  fi
  
  return 0
}

# Fonction pour obtenir l'IP publique avec plusieurs services de secours
get_public_ip() {
  local ip=""
  local ip_cache_file="$CACHE_DIR/public_ip.txt"
  
  # V√©rifier si le cache est valide
  if is_cache_valid "$ip_cache_file" "$CACHE_TIMEOUT"; then
    ip=$(cat "$ip_cache_file")
    debug_log "Using cached IP: $ip"
    echo "$ip"
    return 0
  fi
  
  # Essayer chaque service jusqu'√† obtenir une r√©ponse
  for service in "${IP_SERVICES[@]}"; do
    debug_log "Trying IP service: $service"
    ip=$(curl -s --max-time "$TIMEOUT" "$service" 2>/dev/null | tr -d '\n' | tr -d ' ' || echo "")
    
    if [[ -n "$ip" ]] && is_valid_ip "$ip"; then
      # Mettre en cache l'IP
      write_cache "$ip_cache_file" "$ip"
      
      debug_log "Got IP from $service: $ip"
      echo "$ip"
      return 0
    fi
  done
  
  debug_log "Failed to get public IP from all services"
  echo ""
  return 1
}

# Fonction pour obtenir le code pays √† partir d'une IP
get_country_code() {
  local ip="$1"
  local country=""
  local ip_key="${ip//:/_}"
  local country_cache_file="$CACHE_DIR/country_${ip_key}.txt"
  
  # V√©rifier si le cache est valide
  if is_cache_valid "$country_cache_file" "$CACHE_TIMEOUT"; then
    country=$(cat "$country_cache_file")
    debug_log "Using cached country code for $ip: $country"
    echo "$country"
    return 0
  fi
  
  # Essayer chaque service jusqu'√† obtenir une r√©ponse
  for service_template in "${COUNTRY_SERVICES[@]}"; do
    # Remplacer %s par l'IP dans le template
    local service="${service_template//%s/$ip}"
    
    debug_log "Trying country service: $service"
    country=$(curl -s --max-time "$TIMEOUT" "$service" 2>/dev/null | tr -d '\n' | tr 'a-z' 'A-Z' || echo "")
    
    if [[ -n "$country" && "$country" =~ ^[A-Z]{2}$ ]]; then
      # Mettre en cache le code pays
      write_cache "$country_cache_file" "$country"
      
      debug_log "Got country from $service: $country"
      echo "$country"
      return 0
    fi
  done
  
  debug_log "Failed to get country code for IP $ip from all services"
  echo ""
  return 1
}

# Fonction pour obtenir le nom du serveur ProtonVPN
get_server_name() {
  local vpn_name="$1"
  local server_name=""
  local server_cache_file="$CACHE_DIR/server_name.txt"
  local server_cache_timeout=60  # 1 minute (plus court car peut changer)
  
  # V√©rifier si le cache est valide
  if is_cache_valid "$server_cache_file" "$server_cache_timeout"; then
    server_name=$(cat "$server_cache_file")
    debug_log "Using cached server name: $server_name"
    echo "$server_name"
    return 0
  fi
  
  # Essayer d'extraire le nom du serveur des logs ProtonVPN
  if [[ -f "$VPN_LOG_PATH" ]]; then
    local log
    log=$(tail -n 200 "$VPN_LOG_PATH" 2>/dev/null || echo "")
    
    # Recherche de diff√©rents formats possibles dans les logs
    for pattern in 'Server: *[^/ ]+' 'Connected to [^/ ]+' 'server=[^/ ,]+'; do
      if printf '\n' | grep -P '' >/dev/null 2>&1; then
        server_name=$(echo "$log" | grep -oP "$pattern" | awk '{print $NF}' | tail -n 1 | tr -d ',' || echo "")
      else
        server_name=$(echo "$log" | grep -oE "$pattern" | awk '{print $NF}' | tail -n 1 | tr -d ',' || echo "")
      fi
      if [[ -n "$server_name" ]]; then
        break
      fi
    done
  fi
  
  # Fallback sur le nom de la connexion VPN si aucun serveur trouv√©
  server_name=${server_name:-$vpn_name}
  
  # Mettre en cache le nom du serveur
  write_cache "$server_cache_file" "$server_name"
  
  debug_log "Server name (from logs or fallback): $server_name"
  echo "$server_name"
  return 0
}

# Fonction pour obtenir le drapeau √† partir du code pays
get_flag() {
  local country_code="$1"
  local flag_file="$CONFIG_DIR/flags"
  
  # Si un fichier de drapeaux personnalis√© existe, l'utiliser
  if [[ -f "$flag_file" ]]; then
    local custom_flag
    custom_flag=$(grep -i "^$country_code:" "$flag_file" | cut -d':' -f2 || echo "")
    if [[ -n "$custom_flag" ]]; then
      echo "$custom_flag"
      return 0
    fi
  fi
  
  # Sinon, utiliser la liste int√©gr√©e
  case "$country_code" in
    FR) echo "üá´üá∑" ;;
    CH) echo "üá®üá≠" ;;
    US) echo "üá∫üá∏" ;;
    DE) echo "üá©üá™" ;;
    GB|UK) echo "üá¨üáß" ;;
    NL) echo "üá≥üá±" ;;
    SE) echo "üá∏üá™" ;;
    CA) echo "üá®üá¶" ;;
    ES) echo "üá™üá∏" ;;
    IT) echo "üáÆüáπ" ;;
    JP) echo "üáØüáµ" ;;
    AU) echo "üá¶üá∫" ;;
    BR) echo "üáßüá∑" ;;
    IN) echo "üáÆüá≥" ;;
    RU) echo "üá∑üá∫" ;;
    CN) echo "üá®üá≥" ;;
    KR) echo "üá∞üá∑" ;;
    SG) echo "üá∏üá¨" ;;
    *) echo "üè≥Ô∏è" ;;  # Drapeau blanc si inconnu
  esac
}

# Fonction pour basculer l'affichage de l'IP
toggle_ip_display() {
  if [[ -f "$TOGGLE_FILE" ]]; then
    rm -f "$TOGGLE_FILE"
    debug_log "IP display toggled OFF"
  else
    touch "$TOGGLE_FILE"
    debug_log "IP display toggled ON"
  fi
}

# Fonction pour v√©rifier si l'IP doit √™tre affich√©e
should_show_ip() {
  [[ -f "$TOGGLE_FILE" ]]
}

# Fonction principale
main() {
  # Initialisation
  init
  
  # G√©rer les clics de souris (i3blocks passe BLOCK_BUTTON)
  if [[ -n "${BLOCK_BUTTON:-}" ]]; then
    case "$BLOCK_BUTTON" in
      1|2|3)  # Clic gauche, milieu ou droit
        toggle_ip_display
        ;;
    esac
  fi
  
  # 1) D√©tecter toute interface VPN active (en excluant Tailscale)
  local vpn_line
  if ! command -v nmcli >/dev/null 2>&1; then
    echo "$DISCONNECTED_MSG"
    echo
    debug_log "nmcli not found, exiting."
    exit 0
  fi
  vpn_line=$(nmcli -t -f NAME,TYPE,DEVICE connection show --active | grep -iE 'proton|wireguard|tun|vpn' | grep -v 'tailscale' | head -n 1 || true)
  
  debug_log "Active connections list:"
  if [[ $DEBUG_MODE -eq 1 ]]; then
    nmcli -t -f NAME,TYPE,DEVICE connection show --active >> "$DEBUG_FILE" 2>>"$DEBUG_FILE"
  fi
  debug_log "Selected vpn_line='$vpn_line'"
  
  # Si aucune connexion VPN n'est d√©tect√©e
  if [[ -z "$vpn_line" ]]; then
    echo "$DISCONNECTED_MSG"
    echo                                    # n√©cessaire pour i3blocks
    debug_log "No VPN connection detected, exiting."
    exit 0
  fi
  
  # Extraction du nom et de l'interface
  local vpn_name vpn_iface
  vpn_name=${vpn_line%%:*}
  vpn_iface=${vpn_line##*:}
  debug_log "VPN_NAME='$vpn_name', VPN_IFACE='$vpn_iface'"
  
  # 2) R√©cup√©rer l'IP publique
  local pub_ip
  pub_ip=$(get_public_ip)
  
  # Si aucune IP publique n'est d√©tect√©e
  if [[ -z "$pub_ip" ]]; then
    echo "$NO_IP_MSG"
    echo
    debug_log "Public IP is empty, exiting."
    exit 0
  fi
  
  # 3) R√©cup√©rer le code pays
  local country_code
  country_code=$(get_country_code "$pub_ip")
  debug_log "COUNTRY_CODE='$country_code'"
  
  # 4) Obtenir le nom du serveur
  local server_name
  server_name=$(get_server_name "$vpn_name")
  
  # 5) Obtenir le drapeau
  local flag
  flag=$(get_flag "$country_code")
  debug_log "FLAG='$flag'"
  
  # 6) Affichage final - avec ou sans IP selon l'√©tat du toggle
  if should_show_ip; then
    echo "$flag $server_name ($pub_ip)"
    debug_log "Displaying with IP: $flag $server_name ($pub_ip)"
  else
    echo "$flag $server_name"
    debug_log "Displaying without IP: $flag $server_name"
  fi
  echo
  
  debug_log "Script completed at $(date)"
  exit 0
}

# Ex√©cution du programme principal
main "$@"
